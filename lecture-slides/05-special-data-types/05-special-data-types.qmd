---
title: "WEEK 5: SPECIAL DATA TYPES"
format: 
  revealjs:
    theme: [default, ../../slide_custom.scss]
    auto-stretch: false
editor: source
self-contained: true
---

```{r setup}
#| include: false
#| message: false
library(tidyverse)
library(palmerpenguins)
```

## Monday, February 6th

Today we will...

+ Final Project Group Formation
+ New Material
  + Working with Date & Time Variables
+ [PA 5.1: Zodiac Killer](https://earobinson95.github.io/stat331-calpoly/practice-activities/PA5_1-zodiac-killer.html)

## Final Project Group Formation

You will be completing a final project in Stat 331/531 in teams of four.

+ **Group Formation Survey** due **Friday, 2/9 at 11:59pm**
  + Help me gather information about your preferences and work styles to facilitate team formation.
  + Your team does not all need to be in the same section, but you might find it useful for in-class work time.
+ Group Contracts
+ Project Proposal
+ Final Deliverable

# Date + Time Variables


## Why are dates and times tricky?

When parsing dates and times, we have to consider complicating factors like...

+ Daylight Savings Time.
  + One day a year is 23 hours; one day a year is 25 hours.
  + Some places use it, some don't.
+ Leap years -- most years have 365 days, some have 366.
+ Time zones.


## `lubridate`

:::: {.columns}
::: {.column width="80%"}
**Common Tasks**

+ Convert a date-like variable ("May 8, 1995") to a date or date-time object.

+ Find the weekday, month, year, etc from a date-time object.

+ Convert between time zones.

:::
::: {.column width="20%"}

```{r}
#| fig-align: center
knitr::include_graphics("https://github.com/rstudio/hex-stickers/blob/main/thumbs/lubridate.png?raw=true")
```

:::
::::

::: callout-note
The `lubridate` package  **loads** with `tidyverse`.

:::


## `date-time` Objects

There are multiple **data types** for dates and times.


+ A date:
  + `date` or `Date`
+ A date and a time (identifies a unique instant in time):
  + `dtm`
  + `POSIXlt` -- stores date-times as the number of seconds since January 1, 1970 ("Unix Epoch")
  + `POSIXct` -- stores date-times as a list with elements for second, minute, hour, day, month, year, etc.


## Creating `date-time` Objects

Create a date from individual components:

```{r}
#| echo: true
make_date(year = 1995, month = 05, day = 08)
```

. . .

Create a date from a string:

```{r}
#| echo: true
mdy("May 8, 1995")
```

```{r}
#| echo: true
dmy("8-May-1995", tz = "America/Chicago")
```

```{r}
#| echo: true
dmy_hms("8-May-1995 9:32:12", tz = "America/Chicago")
```

```{r}
#| echo: true
as_datetime("95-05-08", format = "%y-%m-%d")
```

```{r}
#| echo: true
parse_datetime("5/8/1995", format = "%m/%d/%Y")
```


## Creating `date-time` Objects

![](images/date_symbols.png){width=80%}


## Common Mistake with Dates

*What's wrong here?*

```{r}
#| echo: true
as_datetime(2023-02-6)
```

<br>

```{r}
#| echo: true
my_date <- 2023-02-6
my_date
```

<br>

. . .

Make sure you use quotes!

+ 2,015 seconds $\approx$ 33.5 minutes


## Extracting `date-time` Components

```{r}
#| echo: true
bday <- ymd_hms("1995-05-08 9:32:12", tz = "America/Chicago")
bday
```

<br>

:::: columns
::: column
```{r}
#| echo: true
year(bday)
month(bday)
day(bday)
```
:::
::: column
```{r}
#| echo: true
wday(bday)
wday(bday, label = TRUE, abbr = FALSE)
```
:::
::::


## Subtraction with  `date-time` Objects

Doing subtraction gives you a `difftime` object.

+ `difftime` objects do not always have the same units -- it depends on the scale of the objects you are working with.

How old am I?

```{r}
#| echo: true
today() - mdy(05081995)
```

How long did it take me to finish a typing challenge?

```{r}
#| echo: true
begin  <- mdy_hms("3/1/2023 13:04:34")
finish <- mdy_hms("3/1/2023 13:06:11")
finish - begin
```


## Durations and Periods

**Durations** will always give the time span in an **exact number of seconds**.

```{r}
#| echo: true
as.duration(today() - mdy(05081995))
```

```{r}
#| echo: true
as.duration(finish - begin)
```

. . .

**Periods** will give the time span in more approximate, but **human readable times**.

```{r}
#| echo: true
as.period(today() - mdy(05081995))
```

```{r}
#| echo: true
as.period(finish - begin)
```


## Durations and Periods

We can also **add** time:

+ `days()`, `years()`, etc. will add a **period** of time.
+ `ddays()`, `dyears()`, etc. will add a **duration** of time.

. . .

Because durations use the **exact** number of seconds to represent days and years, you might get unexpected results:

When is is my 99th birthday?

```{r}
#| echo: true
mdy(05081995) + years(99)
```

```{r}
#| echo: true
mdy(05081995) + dyears(99)
```


## Time Zones

**Time zones are complicated!**

Specify time zones in the form:

+ {continent}/{city} -- “America/Chicago”, “Africa/Nairobi”
+ {ocean}/{city} -- “Pacific/Auckland”

. . .

What time zone does R think I'm in?

```{r}
#| echo: true
Sys.timezone()
```


## Time Zones (Can Taylor Swift make it to the Superbowl?)

You can change the time zone of a date in two ways:

```{r}
#| echo: true
x <- ymd_hms("2024-02-11 18:00:00", tz = "Asia/Tokyo")
```

:::panel-tabset

### `with_tz()`

Keeps the instant in time the same, but changes the visual representation.

```{r}
#| echo: true
x |> 
  with_tz()
x |> 
  with_tz(tzone = "America/Los_Angeles")
```

### `force_tz()`

Changes the instant in time by forcing a time zone change.

```{r}
#| echo: true
x |> 
  force_tz()
x |> 
  force_tz(tzone = "America/Los_Angeles")
```

:::


## Common Mistake with Dates

When you read data in or create a new date-time object, the default time zone (if not specified) is UTC.

+ UTC (Universal Time Coordinated) is the same as GMT (Greenwich Mean Time).

Make sure you specify your desired time zone!

```{r}
#| echo: true
x <- mdy("05/08/1995")
tz(x)
```

```{r}
#| echo: true
x <- mdy("05/08/1995", tz = "America/Chicago")
tz(x)
```

## [PA 5.1: Zodiac Killer](https://earobinson95.github.io/stat331-calpoly/practice-activities/PA5_1-zodiac-killer.html)

One of the most famous mysteries in California history is the identity of the so-called “Zodiac Killer”, who murdered 7 people in Northern California between 1968 and 1969. A new murder was committed last year in California, suspected to be the work of a new Zodiac Killer on the loose.

Unfortunately, the date and time of the murder is not known. You have been hired to crack the case. Use the clues below to discover the murderer’s identity.

> Submit the name of the killer to the Canvas Quiz.

## To do...

+ **PA 5.1: Zodiac Killer**
  + Due Thursday, 2/8 at 8:00am
  
+ **Final Project Group Formation Survey**
  + Due Friday, 2/9 at 11:59pm
  
+ [**Lab 5: Murder Mystery in SQL City**](https://earobinson95.github.io/stat331-calpoly/lab-assignments/lab5/murder-in-sql-city.html)
  + Due Monday 2/12 at 11:59pm
  
## Thursday, February 8th

Today we will...

+ Review
  + PA 5.1: Zodiac Killer
  + Lab 4: Childcare Costs
+ Midterm Exam Thursday, 2/15: What to Expect
+ New Material
  + Strings
  + Regular Expressions
+ Example: "Messy" Covid Variants
+ [PA 5.2: Scrambled Message](https://earobinson95.github.io/stat331-calpoly/practice-activities/PA5_2-scrambled-message-regex.html)

## [Midterm Exam](https://earobinson95.github.io/stat331-calpoly/midterm-exam/mt-everest/what-to-expect-midterm-exam.html) -- Thursday, 2/15

+ This is a three-part exam:
  1. You will first complete a **General Questions** section on paper and **without your computer**.
  2. After you turn that in, you will complete a **Short Answer** section **with your computer**.
    + *You will have the one hour and 50 minute class period to complete the first two sections.*
  3. The third section, **Open-Ended Analysis**, will be started in class and due **24 hours** after the end of class.


## [Midterm Exam](https://earobinson95.github.io/stat331-calpoly/midterm-exam/mt-everest/what-to-expect-midterm-exam.html) -- Thursday, 2/15

+ The exam is worth a total of 100 points.
  + Approx. 20 pts, 30 pts, and 50 pts for the three sections.
+ I will provide a `.qmd` template for the Short Answer.
+ You will create your own `.qmd` for the Open-Ended Analysis. **You are encouraged to create this ahead of time.**

::: callout-caution
While the coding tasks are open-resource, you will likely run out of time if you have to look everything up. Know what functions you might need and where to find documentation for implementing these functions.
:::

# `stringr`

## strings

A **string** is a bunch of **characters**.

Don't confuse a **string** (many characters, one object) with a **character vector** (vector of strings).

<br>

```{r}
#| echo: true
my_string <- "Hi, my name is Bond!"
my_vector <- c("Hi", "my", "name", "is", "Bond")
```

<br>

```{r}
#| echo: true
my_string
```

<br>

```{r}
#| echo: true
my_vector
```

# `stringr`

:::: columns
::: column
**Common tasks**

+ Find which strings contain a particular pattern

+ Remove or replace a pattern

+ Edit a string (for example, make it lowercase)
:::
::: column
```{r}
#| fig-align: center
#| out-width: 40%
knitr::include_graphics("https://github.com/rstudio/hex-stickers/blob/main/PNG/stringr.png?raw=true")
```
:::
::::

::: callout-note 
The package `stringr` is very useful for strings!  

+ `stringr` loads with the `tidyverse`.

+ all the functions are `str_xxx()`.
:::

## `pattern = `

The **pattern argument** in all of the `stringr` functions ...

```{r}
#| eval: false
#| echo: true
my_vector <- c("Hello,", "my name is", "Bond", "James Bond")

str_detect(my_vector, pattern = "Bond")
str_locate(my_vector, pattern = "Bond")
str_match(my_vector, pattern = "Bond")
str_extract(my_vector, pattern = "Bond")
str_subset(my_vector, "pattern = Bond")
```

::: callout-note
Discuss with a neighbor. For each of these functions, give:

+ The **object structure** of the output.
+ The **data type** of the output.
+ A brief explanation of what they do.
::::


## `str_detect()`

Returns **logical vector** `TRUE/FALSE` indicating if the pattern was found in that element of the original vector

```{r}
#| echo: true
my_vector <- c("Hello,", "my name is", "Bond", "James Bond")
str_detect(my_vector, pattern = "Bond")
```

+ Pairs well with `filter()`
+ Could be used with `summarise()` and `sum` or `mean`

::: {.callout-note collapse="true"}
### Related functions 
`str_subset()` returns just the strings that contain the match

`str_which()` returns the indexes of strings that have a match
:::

## `str_match()` 

Returns **character matrix** with either `NA` or the pattern, depending on if the pattern was found.

```{r}
#| echo: true
my_vector <- c("Hello,", "my name is", "Bond", "James Bond")
str_match(my_vector, pattern = "Bond")
```

## `str_extract()` 

Returns **character vector** with either `NA` or the pattern, depending on if the pattern was found.

```{r}
#| echo: true
my_vector <- c("Hello,", "my name is", "Bond", "James Bond")
str_extract(my_vector, pattern = "Bond")
```

::: callout-warning
`str_extract()` only returns the **first** pattern match.

Use `str_extract_all()` to return **every** pattern match.
:::

## `str_locate()` 

Returns a **date frame** with two **numeric variables** for the starting and ending location, giving either `NA` or the start and end position of the pattern.

```{r}
#| echo: true
my_vector <- c("Hello,", "my name is", "Bond", "James Bond")
str_locate(my_vector, pattern = "Bond")
```

## `str_subset()`

Returns a **character vector** with a subset of the original **character vector** with elements where the pattern occurs.

```{r}
#| echo: true
my_vector <- c("Hello,", "my name is", "Bond", "James Bond")
str_subset(my_vector, pattern = "Bond")
```

::: callout-note
### Related Functions

`str_sub()` extracts values based on location.
:::

## Replace / Remove patterns

::: panel-tabset

### `str_replace()`

replaces the **first** matched pattern

+ Pairs well with `mutate()`

```{r}
#| echo: true
str_replace(my_vector, pattern = "Bond", replace = "Franco")
```

### `str_remove()`

Removes the **first** matched pattern

Special case -- `str_replace(x, pattern, replace = "")`

```{r}
#| echo: true
my_vector <- c("Hello,", "my name is", "Bond", "James Bond")
str_remove(my_vector, pattern = "Bond")
```

:::

::: {.callout-note collapse="true"}
### Related functions 

`str_replace_all()` replaces **all** matched patterns

`str_remove_all()` removes **all** matched patterns
:::

## Make edits

Convert letters in the string to a specific capitalization format.

::: panel-tabset

### `str_to_lower()` 

converts all letters in the strings to lowercase

<br>

```{r}
#| echo: true
my_vector <- c("Hello,", "my name is", "Bond", "James Bond")
str_to_lower(my_vector)
```

### `str_to_upper()` 

converts all letters in the strings to uppercase

<br>

```{r}
#| echo: true
str_to_upper(my_vector)
```

### `str_to_title()` 

converts the first letter of the strings to uppercase

<br>


```{r}
#| echo: true
str_to_title(my_vector)
```

:::


<!-- ## `separate_xxx_delim()` -->

<!-- `separate_longer_delim()` -->

<!-- `separate_wider_delim()` -->

## Combine Strings

::: panel-tabset
### `str_c()`

Joins multiple strings into a single string.

```{r}
#| echo: true
prompt <- "Hello, my name is"
first  <- "James"
last   <- "Bond"
str_c(prompt, last, ",", first, last, sep = " ")
```

::: callout-note
Similar to `paste()` and `paste0()`
:::

### `str_flatten()`

Combines into a single string.

```{r}
#| echo: true
my_vector <- c("Hello,", "my name is", "Bond", "James Bond")
str_flatten(my_vector, collapse = " ")
```

::: callout-note
`str_c()` will do the same thing, but it it is encouraged to use `str_flatten()` instead.
:::

### `str_glue()`

Uses environment to create a string and evaluates {expressions}.

```{r}
#| echo: true
first <- "James"
last <- "Bond"
str_glue("My name is {last}, {first} {last}")
```

::: callout-tip
See the R package [`glue`](https://glue.tidyverse.org/)!
:::

:::

## Hints and Tips for Success

```{r}
#| echo: false
library(liver)
data(cereal)
```

+ Refer to the [`stringr` cheatsheet](https://posit.co/wp-content/uploads/2022/10/strings-1.pdf)

+ Remember that `str_xxx` functions need the first argument to be a **vector of strings**, not a **data set**.
  + You might want to use them *inside* functions like `filter()` or `mutate()`.

```{r}
#| echo: true
#| code-line-numbers: 3
cereal |> 
  mutate(
    is_bran = str_detect(name, "Bran"), 
    .after = name
  )
```

# regex

```{r}
#| fig-align: center
#| out-width: 70%
knitr::include_graphics("images/regular_expressions.png")
```

## Regular Expressions

> "Regexps are a very terse language that allow you to describe patterns in 
> strings."
>
> *R for Data Science*

R uses "extended" regular expressions, which are common.

```{r}
#| echo: true
#| eval: false
#| code-line-numbers: 2
str_detect(string  = my_string_vector, 
           pattern = "REGULAR EXPRESSION"
           )
```

[Web app to test R regular expressions](https://spannbaueradam.shinyapps.io/r_regex_tester/)

::: callout-tip
Regular expressions are a reason to use `stringr`!

You might encounter `gsub()`, `grep()`, etc. from Base R.
:::

## Meta Characters `.` `^`  `$` `\`  `|` `*` `+` `?` `{` `}` `[` `]` `(` `)`

::: panel-tabset

### Wild card `.`

```{r}
#| echo: true
toung_twister <- c("She", "sells", "seashells", "by", "the", "seashore!")
toung_twister
```
<br>
`.` Represents any character

```{r}
#| echo: true
str_subset(toung_twister, pattern = ".ells")
```

### Anchoring `^ $`

```{r}
#| echo: true
toung_twister <- c("She", "sells", "seashells", "by", "the", "seashore!")
toung_twister
```

<br>

`^` Looks at the beginning  

```{r}
#| echo: true
str_subset(toung_twister, pattern = "^s")
```

`$` Looks at the end  

```{r}
#| echo: true
str_subset(toung_twister, pattern = "s$")
```

### Quantifiers `? + *`

```{r}
#| echo: true
shells_str <- c("shes", "shels", "shells", "shellls", "shelllls")
shells_str
```

<br>

`?` Occurs 0 or 1 times  

```{r}
#| echo: true
str_subset(shells_str, pattern = "shel?s")
```

`+` Occurs 1 or more times

```{r}
#| echo: true
str_subset(shells_str, pattern = "shel+s")
```

`*` Occurs 0 or more times

```{r}
#| echo: true
str_subset(shells_str, pattern = "shel*s")
```

### More Quantifiers `{}`

```{r}
#| echo: true
shells_str <- c("shes", "shels", "shells", "shellls", "shelllls")
shells_str
```

<br>

`{n}` matches exactly n times.

```{r}
#| echo: true
str_subset(shells_str, pattern = "shel{2}s")
```

`{n,}` matches at least n times.

```{r}
#| echo: true
str_subset(shells_str, pattern = "shel{2,}s")
```

`{n,m}` matches between n and m times.

```{r}
#| echo: true
str_subset(shells_str, pattern = "shel{1,3}s")
```
:::

## Groups `()`

Groups can be created with `( )`

`|` -- "either" / "or"

<br>
```{r}
#| echo: true
toung_twister2 <- c("Peter", "Piper", "picked", "a", "peck", "of", "pickled", "peppers!")
toung_twister2
```

<br>

```{r}
#| echo: true
str_subset(toung_twister2, pattern = "p(e|i)ck")
```

## Character Classes `[]`

```{r}
#| echo: true
toung_twister2 <- c("Peter", "Piper", "picked", "a", "peck", "of", "pickled", "peppers!")
```

. . .

```{r}
#| echo: true
str_subset(toung_twister2, pattern = "p[ei]ck")
```
. . .

`[^ ]` except - think "not"

```{r}
#| echo: true
str_subset(toung_twister2, pattern = "p[^i]ck")
```

. . .

`[ - ]` range

```{r}
#| echo: true
str_subset(toung_twister2, pattern = "p[ei]ck[a-z]")
```

. . .

`[Pp]` Capitalization matters

```{r}
#| echo: true
str_subset(toung_twister2, pattern = "^p")
```

```{r}
#| echo: true
str_subset(toung_twister2, pattern = "^[Pp]")
```

## `[]` Character Classes

::: panel-tabset
### Shortcuts
+ [A-Z] matches any capital letter.
+ [a-z] matches any lowercase letter.
+ [A-z] or [:alpha:] matches any letter
+ [0-9] or [:digit:] matches any number
+ See the stringr cheatsheet for more shortcuts, like [:punct:]

### More Shortcuts
`\w` Looks for any **"word"**  (conversely "not" "word" `\W`) 

`\d` Looks for any **digit** (conversely "not" digit `\D`) 

`\s` Looks for any **whitespace** (conversely "not" whitespace `\S`) 
:::

## Let's try it out!

Discuss with a neighbor which regular expressions would search for words that do the following:

+ end with a vowel
+ start with x, y, or z
+ *do not* contain x, y, or z
+ contain [British spelling](https://www.oxfordinternationalenglish.com/differences-in-british-and-american-spelling/)

Test your answers out on

```{r}
#| echo: true
test_vec <- c("zebra", "xray", "apple", "yellow", "color", "colour", "summarize", "summarise")
```

## Escape `\`

In order to match a special character you need to "escape" first

::: callout-warning
In general, look at punctuation characters with suspicion.
:::

```{r}
toung_twister3 <- c("How", "much", "wood", "could", "a", "woodchuck", "chuck", "if", "a", "woodchuck", "could", "chuck", "wood?")
toung_twister3 
```
```{r}
#| echo: true
#| error: true
str_subset(toung_twister3, pattern = "?")
```

```{r}
#| echo: true
#| error: true
str_subset(toung_twister3, pattern = "\\?")
```

::: callout-note
Could also use `[]` character class

```{r}
#| echo: true
#| error: true
str_subset(toung_twister3, pattern = "[?]")
```
:::

## When in Doubt
<br>
<br>
```{r}
#| fig-align: center
#| out-width: 80%
knitr::include_graphics("images/backslashes.png")
```

Use the [web app to test R regular expressions](https://spannbaueradam.shinyapps.io/r_regex_tester/)

## Tips for working with regex

+ Read the regular expressions out loud like a "request"
+ Test out your expressions on small examples first.

::: {.callout-note collapse="true"}  
### `str_view()`
```{r}
#| echo: true
str_view(c("shes", "shels", "shells", "shellls", "shelllls"), "l+")
```
:::

+ I use the [`stringr` cheatsheet](https://posit.co/wp-content/uploads/2022/10/strings-1.pdf) more than any other package cheatsheet!

+ Be kind to yourself when working with regular expressions!

+ Read the regular expressions out loud like a "request"


# Strings in the `tidyverse`

```{r}
#| include: false
library(readxl)
library(tidyverse)
military <- read_xlsx(here::here("practice-activities",
                                 "data", 
                                 "gov_spending_per_capita.xlsx"), 
                      sheet = "Share of Govt. spending", 
                      skip  = 7, 
                      n_max  = 191)
```

## `stringr` functions + `dplyr` verbs!

Find countries that start with an "A":

```{r}
#| echo: true
#| eval: false
#| code-line-numbers: "2"
military |> 
  filter(str_detect(string  = Country, 
                    pattern = "^A"
                    )
         ) |> 
  distinct(Country)
```

```{r}
#| eval: true
#| echo: false
military |> 
  filter(str_detect(string = Country, 
                    pattern = "^A"
                    )
         ) |> 
  distinct(Country) |> 
  knitr::kable() |> 
  kableExtra::scroll_box(height = "125px") |> 
  kableExtra::kable_styling(font_size = 20)
```

. . .

Find the proportion of countries containing a compass direction:

```{r}
#| echo: true
#| code-line-numbers: "3-4"
military |> 
  distinct(Country) |> 
  summarize(prop = mean(str_detect(string = Country,
                                   pattern = "[Nn]orth|[Ss]outh|[Ee]ast|[Ww]est"
                                   )
                        )
            )
```

## `matches(pattern)`

Selects all variables with a name that matches the supplied pattern

+ pairs well with `select()`, `rename_with()`, and `across()`

::: panel-tabset

### Before
```{r}
#| echo: true
military_clean <- military |> 
  mutate(across(`1988`:`2019`, 
                ~ na_if(.x, y = ". .")
                ),
         across(`1988`:`2019`, 
                ~ na_if(.x, y = "xxx")
                )
         )
```

### With regex
```{r}
#| echo: true
military_clean <- military |> 
  mutate(across(matches("[1-9]{4}"), 
                ~ na_if(.x, y = ". .")),
         across(matches("[1-9]{4}"), 
                ~ na_if(.x, y = "xxx")))
```
:::

## "Messy" Covid Variants

I received this data from a grad school colleague the other day who asked if I knew how to "clean" it.

![](images/covid-data-snip.JPG)

What is that column?!

`[{'variant': 'Other', 'cumWeeklySequenced': 2366843.0, 'newWeeklyPercentage': 4.59}, {'variant': 'V-20DEC-01 (Alpha)', 'cumWeeklySequenced': 0.0, 'newWeeklyPercentage': 0.0}, {'variant': 'V-21APR-02 (Delta B.1.617.2)', 'cumWeeklySequenced': 0.0, 'newWeeklyPercentage': 0.0}, {'variant': 'V-21OCT-01 (Delta AY 4.2)', 'cumWeeklySequenced': 0.0, 'newWeeklyPercentage': 0.0}, {'variant': 'V-22DEC-01 (Omicron CH.1.1)', 'cumWeeklySequenced': 2366843.0, 'newWeeklyPercentage': 24.56}, {'variant': 'V-22JUL-01 (Omicron BA.2.75)', 'cumWeeklySequenced': 2366843.0, 'newWeeklyPercentage': 8.93}, {'variant': 'V-22OCT-01 (Omicron BQ.1)', 'cumWeeklySequenced': 2366843.0, 'newWeeklyPercentage': 49.57}, {'variant': 'VOC-21NOV-01 (Omicron BA.1)', 'cumWeeklySequenced': 2366843.0, 'newWeeklyPercentage': 0.02}, {'variant': 'VOC-22APR-03 (Omicron BA.4)', 'cumWeeklySequenced': 2366843.0, 'newWeeklyPercentage': 0.08}, {'variant': 'VOC-22APR-04 (Omicron BA.5)', 'cumWeeklySequenced': 2366843.0, 'newWeeklyPercentage': 5.59}, {'variant': 'VOC-22JAN-01 (Omicron BA.2)', 'cumWeeklySequenced': 2366843.0, 'newWeeklyPercentage': 1.41}, {'variant': 'unclassified_variant', 'cumWeeklySequenced': 2366843.0, 'newWeeklyPercentage': 5.26}]`

## Enter `stringr`!

Let's see how this works.

## [PA 5.2: Scrambled Message](https://earobinson95.github.io/stat331-calpoly/practice-activities/PA5_2-scrambled-message-regex.html)

In this activity, you will be using regular expressions to decode a message.

+ Remember, the `stringr` functions go *inside* `dplyr` verbs like `mutate()` and `filter()`. Think of them as you would `as.factor()`

+ [Reminder about Indexing Vectors](https://earobinson95.github.io/stat331-calpoly-text/00-prereading.html#indexing-by-location)

```{r}
#| echo: true
x <- c("She", "sells", "seashells", "by", "the", "seashore!")
```

:::: {.columns}
::: {.column width="50%"}

  + Grab elements out of a vector with `[]`.

```{r}
#| echo: true
x[c(1,4,5)]
```

:::
::: {.column width="50%"}

  + To replace those elements, use `<-` to assign new values.

```{r}
#| echo: true
x[c(1,4,5)] <- ""
```

:::
::::

## To do...

+ **PA 5.2: Scrambled Message**
  + Due Monday, 2/9 at 8:00am

+ **Final Project Group Formation Survey**
  + Due Friday, 2/9 at 11:59pm

+ [**Lab 5: Murder Mystery in SQL City**](https://earobinson95.github.io/stat331-calpoly/lab-assignments/lab5/murder-in-sql-city.html)
  + Due Monday 2/12 at 11:59pm
  
+ **Read Chapter 6: Version Control**
  + **Concept Check 6.1 + 6.2** due Tuesday (2/13) at 8:00am

  